import numpy as np
from itertools import combinations
from functools import wraps

nuc_spin = 0.5


def numpyize(func):
    """Decorator that converts all array-like arguments to NumPy ndarrays.

    Parameters
    ----------
    func : function(*args, **kwargs)
        The function to be decorated. Any positional arguments that are non-scalar
        will be converted to an ndarray

    Returns
    -------
    decorated : function(*newargs, **kwargs)
        The decorated function, with all array-like arguments being ndarrays

    """
    @wraps(func)
    def decorated(*args, **kwargs):
        newargs = list(args)
        for i, a in enumerate(newargs):
            if not np.isscalar(a):
                newargs[i] = np.asanyarray(a)
        return func(*newargs, **kwargs)

    return decorated


def sp_states(pmax, spin):
    """Generates the single-particle states

    The states yielded have a quantum number p and spin s where 0 <= p <= pmax and -spin <= s <= spin.

    Parameters
    ----------
    pmax : int
        The maximum of the p quantum number
    spin : float
        The magnitude of the spin, e.g. 0.5

    Yields
    ------
    p : int
        The p quantum number
    s : float
        The projection of the spin
    """
    assert pmax >= 1, 'p levels run over [1,inf)'

    for p in range(1, pmax+1):
        s = -spin
        while s <= spin:
            yield p, s
            s += 1


def slater(n_particles, p_max, total_m, pairs_only=False):
    """Finds the possible slater determinants with a given total M.

    Parameters
    ----------
    n_particles : int
        The number of (single) particles
    p_max : int
        The maximum p quantum number, or half of the number of available states
    total_m : int or float
        The total spin projection desired

    Returns
    -------
    sds : ndarray
        The possible Slater determinants, as lists of indices. Each row represents a possible determinant, and each
        index corresponds to an index in the list generated by `sp_states`.
    """
    states = np.array(list(sp_states(p_max, nuc_spin)))
    indices = np.array(list(range(np.size(states, 0))))

    sds = []
    for x in combinations(indices, n_particles):
        s = states[list(x)]
        m = s.sum(0)[-1]
        if pairs_only:
            ps = s[:, 0].astype(int)
            bins = np.bincount(ps)
            paired = np.all(bins[bins.nonzero()] == 2)
            if m == total_m and paired:
                sds.append(x)
        else:
            if total_m == m:
                sds.append(x)

    return np.array(sds)


@numpyize
def sd_delta(a, b):
    """Counts the number of different single-particle states between two slater determinants.

    Parameters
    ----------
    a : array-like
        The first Slater determinant
    b : array-like
        The second Slater determinant
    """
    d = 0
    for el in a:
        if el not in b:
            d += 1
    return d

@numpyize
def one_body_element(bra, ket, states):

    # ket is | 1 2 3 >, for example

    if np.array_equal(bra, ket):
        res = 0
        for i in ket:
            p = states[i, 0]
            assert p-1 >= 0, 'invalid p: {}'.format(p)
            res += (p-1)
    else:
        res = 0

    return res


@numpyize
def find_hamiltonian_matrix(sds, states):

    n = np.size(sds, 0)
    hmat = np.zeros((n, n))

    for i in range(n):
        for j in range(i, n):
            hmat[i, j] = one_body_element(sds[j], sds[i], states)

    return hmat


def main():
    states = np.array(list(sp_states(4, 0.5)))
    dets = slater(4, 4, 0, pairs_only=True)
    hmat = find_hamiltonian_matrix(dets, states)
    print(hmat)

if __name__ == '__main__':
    main()
